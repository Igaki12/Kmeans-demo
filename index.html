<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>K-Means クラスタリング・シミュレーター</title>
<style>
  :root {
    --canvas-size: 600px;
  }
  body {
    font-family: system-ui, "Noto Sans JP", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 1rem;
    background: #fafafa;
  }
  h1 { margin: 0 0 0.5rem; font-size: 1.4rem; }
  #controls {
    display: flex;
    gap: 0.8rem;
    flex-wrap: wrap;
    margin-bottom: 0.8rem;
  }
  #controls label { font-size: 0.9rem; }
  #controls input[type="number"] {
    width: 5rem;
    padding: 0.2rem 0.4rem;
    font-size: 0.9rem;
  }
  button {
    padding: 0.4rem 0.8rem;
    font-size: 0.9rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background: #1976d2;
    color: #fff;
  }
  button:disabled { background: #90caf9; cursor: not-allowed; }
  canvas {
    border: 1px solid #b0bec5;
    width: var(--canvas-size);
    height: var(--canvas-size);
    max-width: 100%;
    touch-action: manipulation;
    background: #ffffff;
  }
  /* 小さな表示用の説明 */
  #note { font-size: 0.8rem; color: #555; margin-top: 0.6rem; }
</style>
</head>
<body>
  <h1>K-Means クラスタリング・シミュレーター</h1>
  <div id="controls">
    <label>N (ノード数): <input type="number" id="numPoints" value="100" min="10" max="1000" step="10" /></label>
    <label>K (クラスタ数): <input type="number" id="numClusters" value="5" min="2" max="10" step="1" /></label>
    <button id="initBtn">新規作成</button>
    <button id="stepBtn">ステップ</button>
    <button id="resetBtn">最初から</button>
  </div>
  <canvas id="canvas" width="600" height="600"></canvas>
  <div id="note">図をクリックするか[ステップ]ボタンを押すと1ステップずつ処理を行います</div>

<script>
(() => {
  "use strict";

  // --- 設定値とグローバル変数 -------------------------------------
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const COLORS = [
    "#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", // 塗りつぶし
    "#f44336", "#2196f3", "#4caf50", "#9c27b0", "#ff9800"  // 枠線
  ];

  let points = [];      // [{x,y,cluster}]
  let clusters = [];    // [{x,y,color,outlined,history:[{x,y}]}]
  let stepCount = 0;

  // --- ユーティリティ ---------------------------------------------
  function rand(max) { return Math.random() * max; }
  function distance(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
  function drawCircle(x, y, r, fill, stroke, lineWidth = 1) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth; ctx.stroke(); }
  }
  function drawCross(x, y, size, color, alpha = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x - size, y - size);
    ctx.lineTo(x + size, y + size);
    ctx.moveTo(x - size, y + size);
    ctx.lineTo(x + size, y - size);
    ctx.stroke();
    ctx.restore();
  }

  // --- 初期化 -----------------------------------------------------
  function createSimulation() {
    const N = Number(document.getElementById("numPoints").value);
    const K = Number(document.getElementById("numClusters").value);

    // ノード生成
    points = Array.from({ length: N }, () => ({ x: rand(canvas.width), y: rand(canvas.height), cluster: -1 }));

    // クラスタ生成
    clusters = Array.from({ length: K }, (_, i) => ({
      x: rand(canvas.width),
      y: rand(canvas.height),
      color: COLORS[i % COLORS.length],
      outlined: i >= 5, // 6番目以降は枠線のみ
      history: []
    }));

    stepCount = 0;
    draw();
  }

  // --- アルゴリズムの1ステップ -----------------------------------
  function step() {
    if (!clusters.length) return;
    // Assignment: 最近傍クラスタに割り当て
    points.forEach(p => {
      let minD = Infinity, idx = -1;
      clusters.forEach((c, i) => {
        const d = distance(p.x, p.y, c.x, c.y);
        if (d < minD) { minD = d; idx = i; }
      });
      p.cluster = idx;
    });

    // Update: 各クラスタを重心へ移動
    clusters.forEach((c, i) => {
      const members = points.filter(p => p.cluster === i);
      if (members.length) {
        c.history.push({ x: c.x, y: c.y });
        c.x = members.reduce((sum, p) => sum + p.x, 0) / members.length;
        c.y = members.reduce((sum, p) => sum + p.y, 0) / members.length;
      }
    });

    stepCount++;
    draw();
  }

  // --- 描画 -------------------------------------------------------
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ノードと線を描画
    points.forEach(p => {
      if (p.cluster !== -1) {
        const c = clusters[p.cluster];
        // ノードからクラスタまでの線
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(c.x, c.y);
        ctx.strokeStyle = c.color;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    });

    // ノード (後ろに線を引いているので後ほど塗ると見栄えが良い)
    points.forEach(p => {
      const r = 4;
      if (p.cluster === -1) {
        drawCircle(p.x, p.y, r, "#9e9e9e", "#bdbdbd");
      } else {
        const c = clusters[p.cluster];
        if (!c.outlined) {
          drawCircle(p.x, p.y, r, c.color, null);
        } else {
          drawCircle(p.x, p.y, r, "#ffffff", c.color, 1.5);
        }
      }
    });

    // クラスタの残像
    clusters.forEach(c => {
      c.history.forEach(pos => drawCross(pos.x, pos.y, 6, c.color, 0.2));
    });

    // 現在のクラスタ (×印)
    clusters.forEach(c => drawCross(c.x, c.y, 8, c.color));

    // ステップ数表示
    ctx.fillStyle = "#424242";
    ctx.font = "14px sans-serif";
    ctx.fillText(`ステップ: ${stepCount}`, 8, canvas.height - 8);
  }

  // --- ボタン / イベント ----------------------------------------
  document.getElementById("initBtn").addEventListener("click", createSimulation);
  document.getElementById("stepBtn").addEventListener("click", step);
  document.getElementById("resetBtn").addEventListener("click", () => { stepCount = 0; draw(); });
  canvas.addEventListener("click", step);

  // 初期表示
  createSimulation();
})();
</script>
</body>
</html>